---
title: "Normalizing your data and PCA"
format: html
---

# Introduction

This chapter demonstrates basic unsupervised machine learning concepts using Python.

::: {.callout-tip}
## Learning Objectives

- Understand the difference between supervised and unsupervised learning.
- Apply PCA and clustering to example data.
- Visualize results.
:::
<!-- end callout -->


## Normalization (Z-score Standardization)

Normalization, specifically Z-score standardization, is a data scaling technique that transforms your data to have a mean of 0 and a standard deviation of 1. This is useful for many machine learning algorithms that are sensitive to the scale of input features.

The formula for Z-score is:

$$ z = \frac{x - \mu}{\sigma} $$

Where:
- $x$ is the original data point.
- $\mu$ is the mean of the data.
- $\sigma$ is the standard deviation of the data.

For example, say you have two variables or *features* on very different scales. 


| Age | Weight (grams) |
|-----|------------|
| 25  | 65000      |
| 30  | 70000      |
| 35  | 75000      |
| 40  | 80000      |
| 45  | 85000      |
| 50  | 90000      |
| 55  | 95000      |
| 60  | 100000     |
| 65  | 105000     |
| 70  | 110000     |
| 75  | 115000     |
| 80  | 120000     |

If these are not brought on similar scales, weight will have a dispproportionate influence on whatever machine learning model we build.

Hence we normalize each of the features *separately*, i.e. age is normalized relative to age and weight is normalized relative to weight.

```{python ch2-gen_data}
#| warning: false

import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler

# 1. Generate age and weight data
np.random.seed(42)
age = np.random.normal(45, 15, 100)  # 100 people, mean age 45, std 15
age = np.clip(age, 18, 80)  # Keep ages between 18-80

weight = 70 + (age - 45) * 0.3 + np.random.normal(0, 10, 100)  # Weight correlated with age
weight = np.clip(weight, 45, 120)  # Keep weights between 45-120 kg

print("Original data:")
print(f"Age: mean={age.mean():.1f}, std={age.std():.1f}")
print(f"Weight: mean={weight.mean():.1f}, std={weight.std():.1f}")

# 2. Normalize the data
scaler = StandardScaler()
data = np.column_stack((age, weight))
normalized_data = scaler.fit_transform(data)

age_normalized = normalized_data[:, 0]
weight_normalized = normalized_data[:, 1]

# Histogram: Age (Original)
plt.figure()
plt.hist(age, bins=20, alpha=0.7)
plt.title('Age Distribution (Original)')
plt.xlabel('Age')
plt.ylabel('Frequency')
plt.grid(True, alpha=0.3)
plt.show()

# Histogram: Age (Normalized)
plt.figure()
plt.hist(age_normalized, bins=20, alpha=0.7)
plt.title('Age Distribution (Normalized)')
plt.xlabel('Age (Z-score)')
plt.ylabel('Frequency')
plt.grid(True, alpha=0.7)

plt.tight_layout()
plt.show()
```

* In an ideal scenario a feature/variable such as `weight` might be transformed in the following way after normalization:

```{python ch2-norm-beforeafter-pretty}
#| warning: false
#| echo: false

import numpy as np
import matplotlib.pyplot as plt

# Seed for reproducibility
rng = np.random.default_rng(42)

# Example variable: "weight" (simulate in kg, roughly normal)
weights = rng.normal(loc=70000, scale=12, size=1000)  # mean=70000 g,, std=12 kg

# Z-score normalization (no external dependencies)
weights_mean = weights.mean()
weights_std = weights.std(ddof=0)  # population std for simplicity
weights_z = (weights - weights_mean) / weights_std

#print(f"Original mean: {weights_mean:.2f}, std: {weights_std:.2f}")
#print(f"Z-scored mean: {weights_z.mean():.2f}, std: {weights_z.std(ddof=0):.2f}")

# Plot histograms
fig, axes = plt.subplots(1, 2, figsize=(10, 4), constrained_layout=True)

# Before normalization
axes[0].hist(weights, bins=30, density=True, color="#4C78A8", alpha=0.8, edgecolor="white")
axes[0].set_title("Weight (Before z-score)")
axes[0].set_xlabel("grams")
axes[0].set_ylabel("Density")

# After normalization
axes[1].hist(weights_z, bins=30, density=True, color="#F58518", alpha=0.8, edgecolor="white")
axes[1].set_title("Weight (After z-score)")
axes[1].set_xlabel("z-score")
axes[1].set_ylabel("Density")
axes[1].axvline(0, color="black", linestyle="--", linewidth=1)  # mean at 0
axes[1].set_xlim(-4, 4)

plt.show()
```

* And here is what it might look like for a feature such as `age`.

```{python ch2-norm-zscore-age}
#| warning: false
#| echo: false

import numpy as np
import matplotlib.pyplot as plt

# Seed for reproducibility
rng = np.random.default_rng(42)

# Example variable: "age" in years, constrained to [0, 120]
# Use a scaled Beta distribution to keep values within 0â€“120 with a realistic skew
ages = 120 * rng.beta(a=2.5, b=3.5, size=2000)

# Z-score normalization
age_mean = ages.mean()
age_std = ages.std(ddof=0)
ages_z = (ages - age_mean) / age_std

#print(f"Original mean: {age_mean:.2f}, std: {age_std:.2f}")
print(f"Z-scored mean: {ages_z.mean():.2f}, std: {ages_z.std(ddof=0):.2f}")

# Plot histograms
fig, axes = plt.subplots(1, 2, figsize=(10, 4), constrained_layout=True)

# Before normalization
axes[0].hist(ages, bins=30, range=(0, 120), density=True, color="#4C78A8", alpha=0.85, edgecolor="white")
axes[0].set_title("Age (Before z-score)")
axes[0].set_xlabel("years")
axes[0].set_ylabel("Density")
axes[0].set_xlim(0, 120)

# After normalization
axes[1].hist(ages_z, bins=30, density=True, color="#F58518", alpha=0.85, edgecolor="white")
axes[1].set_title("Age (After z-score)")
axes[1].set_xlabel("z-score")
axes[1].set_ylabel("Density")
axes[1].axvline(0, color="black", linestyle="--", linewidth=1)
axes[1].set_xlim(-3.5, 3.5)

plt.show()
```



::: {.callout-tip}
**NOTE (IMPORTANT CONCEPT)**: 

* After normalization, the *normalized features* are on comparable scales. The features (such as `weight` and `age`) no longer have so much variation. They can be used as input to machine learning algorithms.

* The rule of thumb is to (almost) always *normalize* your data before you use it in a machine learning algorithm. (There are a few exceptions and we will point this out in due course).

:::
<!-- end callout -->







### Data visualization before doing PCA {#sec-datavizbeforePCA}

::::: {#ex-titledaatviz .callout-exercise}

#### exercise_data_visualization

{{< level 1 >}}

Discuss in a group. What is wrong with the following plot?


```{python ch2-exercise-dataviz-150yearold}
#| warning: false
#| echo: false

import numpy as np
import matplotlib.pyplot as plt

# Seed for reproducibility
rng = np.random.default_rng(42)

# Example variable: "age" in years, constrained to [0, 120]
# Use a scaled Beta distribution to keep values within 0â€“120 with a realistic skew
ages = 160 * rng.beta(a=2.5, b=3.5, size=2000)

# Z-score normalization
age_mean = ages.mean()
age_std = ages.std(ddof=0)
ages_z = (ages - age_mean) / age_std

#print(f"Original mean: {age_mean:.2f}, std: {age_std:.2f}")
#print(f"Z-scored mean: {ages_z.mean():.2f}, std: {ages_z.std(ddof=0):.2f}")

# Plot histograms
fig, axes = plt.subplots(1, 2, figsize=(10, 4), constrained_layout=True)

# Before normalization
axes[0].hist(ages, bins=50, density=True, color="#4C78A8", alpha=0.85, edgecolor="white")
axes[0].set_title("Age (Before z-score)")
axes[0].set_xlabel("years")
axes[0].set_ylabel("Density")
axes[0].set_xlim(0, 150)

# After normalization
axes[1].hist(ages_z, bins=50, density=True, color="#F58518", alpha=0.85, edgecolor="white")
axes[1].set_title("Age (After z-score)")
axes[1].set_xlabel("z-score")
axes[1].set_ylabel("Density")
axes[1].axvline(0, color="black", linestyle="--", linewidth=1)
axes[1].set_xlim(-3.5, 3.5)

plt.show()
``` 

:::: {.callout-answer collapse="true"}

#### Looking at your data

Always look at your data before you try and machine learning technique on it. There is a 150 year old person in your data!



::::

:::::





::: {.callout-tip}
**NOTE (IMPORTANT CONCEPT)**: 

* Visualize your data before you do any normalization. If there is anything odd about your data, discuss this with the person who gave you the data or did the experiment. This could be an error in the machine that generated the data or a data entry error. If there is justification, you can remove the data point.

* Then perform normalization and apply a machine learning technique.

:::
<!-- end callout -->




## Setup

```{python}
#| echo: true
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
```

## Example Data

```{python}
#| echo: false

# Generate synthetic data
np.random.seed(42)
X = np.vstack([
    np.random.normal(loc=[0, 0], scale=1, size=(50, 2)),
    np.random.normal(loc=[5, 5], scale=1, size=(50, 2))
])
plt.scatter(X[:, 0], X[:, 1])
plt.title("Synthetic Data")
plt.show()
```

## PCA Example

<!--open tab-->
::: {.callout-note collapse="true"}
::: {.panel-tabset group="language"}

## Python

```{python}
#| echo: true
#| fig-cap: "A simple PCA plot"

pca = PCA(n_components=2)
X_pca = pca.fit_transform(X)
plt.scatter(X_pca[:, 0], X_pca[:, 1])
plt.title("PCA Projection")
plt.show()
```

## R

:::
:::
<!--close tab-->


## Exercise

* Try the same code above but now *without* normalisation.

* What differences do you observe in PCA *with* and *without* normalization?


## Scree plot

A *scree* plot is a simple graph that shows how much variance (information) each principal component explains in your data after running PCA. The x-axis shows the principal components (PC1, PC2, etc.), and the y-axis shows the proportion of variance explained by each one.

You can use a scree plot to decide how many principal components to keep: look for the point where the plot levels off (the *elbow*): this tells you that adding more components doesnâ€™t explain much more variance.


```{python ch2-screeplot}

# Scree plot: variance explained by each component
plt.plot(range(1, len(pca.explained_variance_ratio_) + 1), pca.explained_variance_ratio_, marker='o')
plt.title("Scree Plot")
plt.xlabel("Principal Component")
plt.ylabel("Variance Explained Ratio")
plt.show()
```

A scree plot may have an *elbow* like the plot below.

```{python ch2-screeplot-ideal}
#| echo: false
#| fig.cap: "An idealized scree plot"

from sklearn.datasets import make_blobs

# Generate synthetic data
X, y = make_blobs(n_samples=100, n_features=5, centers=3, random_state=42)

# Print the shape of the generated data
# print(X.shape)

from sklearn.preprocessing import StandardScaler

# Standardize the data X
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Initialize PCA with all components
pca = PCA(n_components=X_scaled.shape[1])

# Fit PCA to the standardized data
pca.fit(X_scaled)

# Transform the standardized data
X_pca = pca.transform(X_scaled)

# Create a figure and axes for the plot
plt.figure(figsize=(8, 5))

# Plot the explained variance ratio
plt.plot(range(1, pca.n_components_ + 1), pca.explained_variance_ratio_, marker='o', linestyle='--')

# Add title and labels
plt.title('Scree Plot')
plt.xlabel('Principal Component')
plt.ylabel('Explained Variance Ratio')

# Add grid
plt.grid(True)

# Display the plot
plt.show()
```

<!--
## Loadings

```{python ch2-loadings}

# pca.components_.T
#feature_names = ["Feature 1", "Feature 2"]  # Replace with your actual feature names if available
#loadings = pd.DataFrame(pca.components_.T, columns=["PC1", "PC2"], index=feature_names)
#print("PCA Loadings:")
#print(loadings)

```
-->

## Clustering Example

PCA is different to clustering where you are trying to find patterns in your data. We will encounter clustering later in the course.

```{python}
#| echo: false
#| fig.cap: "A simple clustering"

kmeans = KMeans(n_clusters=2, random_state=42)
labels = kmeans.fit_predict(X)
plt.scatter(X[:, 0], X[:, 1], c=labels)
plt.title("KMeans Clustering")
plt.show()
```



## ðŸ§  PCA vs. Other Techniques

* PCA is **unsupervised** (no labels used)
* Works best for **linear** relationships
* Alternatives:

  * t-SNE for nonlinear structures

---

## ðŸ§¬ In Practice: Tips for Biologists

* Always **standardize** data before PCA
* Be cautious interpreting PCs biologicallyâ€”PCs are **mathematical constructs**



### Goals of unsupervised learning

* Finding patterns in data

Here is an example from biological data (single-cell sequencing data) (the plot is from [2])[@Aschenbrenner2020].

![Example tSNE ](https://gut.bmj.com/content/gutjnl/70/6/1023/F3.large.jpg)

![Example heatmaps](https://gut.bmj.com/content/gutjnl/70/6/1023/F5.large.jpg)


* Finding interesting patterns

You can also use dimensionality reduction techniques (such as PCA) to find interesting patterns in your data.

```{python ch2-outliers-pca}
#| echo : false

import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler

# Set random seed
np.random.seed(42)

# 1. Generate data with outliers
# Main cluster
main_data = np.random.multivariate_normal(
    mean=[0, 0, 0],
    cov=[[1, 0.5, 0.3],
         [0.5, 1, 0.4],
         [0.3, 0.4, 1]],
    size=950
)

# Outliers
outliers = np.random.multivariate_normal(
    mean=[5, 5, 5],
    cov=[[0.5, 0.1, 0.1],
         [0.1, 0.5, 0.1],
         [0.1, 0.1, 0.5]],
    size=50
)

# Combine data
data = np.vstack([main_data, outliers])

# 2. Apply PCA
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data)
pca = PCA(n_components=2)
data_pca = pca.fit_transform(data_scaled)

# 3. Plot PCA
plt.figure()
plt.scatter(data_pca[:-50, 0], data_pca[:-50, 1], c='blue', alpha=0.6, label='Normal Data')
plt.scatter(data_pca[-50:, 0], data_pca[-50:, 1], c='red', alpha=0.8, s=100, label='Outliers')
plt.title('PCA Projection - Outliers Highlighted')
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

```

* Finding outliers

You can also use dimensionality reduction techniques (such as PCA) to find outliers in your data.


```{python ch2-one_outlier}
#| echo : false

import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler

# Set random seed
np.random.seed(42)

# 1. Generate data with one outlier
# Main cluster
main_data = np.random.multivariate_normal(
    mean=[0, 0, 0],
    cov=[[1, 0.5, 0.3],
         [0.5, 1, 0.4],
         [0.3, 0.4, 1]],
    size=999
)

# Single outlier point
outlier = np.array([[10, 10, 10]])  # One extreme outlier point

# Combine data
data = np.vstack([main_data, outlier])

# 2. Apply PCA
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data)
pca = PCA(n_components=2)
data_pca = pca.fit_transform(data_scaled)

# 3. Plot PCA
plt.figure()
plt.scatter(data_pca[:-1, 0], data_pca[:-1, 1], c='blue', alpha=0.6, label='Normal Data')
plt.scatter(data_pca[-1, 0], data_pca[-1, 1], c='red', alpha=0.8, s=200, label='Single Outlier')
plt.title('PCA Projection - Single Outlier Highlighted')
plt.xlabel('PC1')
plt.ylabel('PC2')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

```


* Finding hypotheses

All of these can be used to generate hypotheses. These hypotheses can be tested by collecting more data.

### Exercise

* Perform PCA on a dataset of US Arrests

Load data and install package

```python
!pip install pca
```

```{python ch2-exercise-pca}
#| echo: false
#| output: false
#| warning: false

!pip install pca
```

```{python ch2-exercise-pca-loaddata}
#| warning: false

from pca import pca
import pandas as pd

# Load the US Arrests data
# Read the USArrests data directly from the GitHub raw URL
url = "https://raw.githubusercontent.com/cambiotraining/ml-unsupervised/main/course_files/data/USArrests.csv"
df = pd.read_csv(url, index_col=0)

print("US Arrests Data (first 5 rows):")
print(df.head())
print("\nData shape:", df.shape)
```


Perform PCA

```{python ch2-pca-usarrests}
#| warning: false

model = pca(n_components=4)
out = model.fit_transform(df)
ax = model.biplot(n_feat=len(df.columns), legend=False)
```

* Variance explained plots

```{python ch2-exercise-pca-var}
#| warning: false

model.plot()
```

* 3D PCA biplots

```{python ch2-exercise-pca-3d}
#| warning: false

model.biplot3d()
```

* Loadings

*Recall*

What is being plotted on the axes (PC1 and PC2) are the `scores`.

The `scores` for each principal component are calculated as follows:

$$
PC_{1} = \alpha X + \beta Y + \gamma Z + .... 
$$

where $X$, $Y$ and $Z$ are the normalized *features*.

The constants $\alpha$, $\beta$, $\gamma$ are determined by the PCA algorithm. They are called the `loadings`.


```{python ch2-loadings-package}
#| warning: false

print(model.results)
```

## Exercise (advanced)

::: {.callout-tip}
Look into the documentation available here for the [PCA package](https://erdogant.github.io/pca/pages/html/Examples.html) and plot prettier *publication ready* plots.
:::
<!-- end callout -->




### Exercise (theoretical) {#sec-ex-theoretical}

::::: {#ex-titletheor .callout-exercise}

#### exercise_theoretical

{{< level 2 >}}

Break up into groups and discuss the following problem:

1. Shown are biological samples with scores

2. The features are genes

* Why are `Sample 33` and `Sample 24` separated from the rest? What can we say about `Gene1`, `Gene 2`, `Gene 3` and `Gene 4`?

* Why is `Sample 2` separated from the rest? What can we say about `Gene1`, `Gene 2`, `Gene 3` and `Gene 4`?

* Can we treat `Sample 2` as an outlier? Why or why not? Argue your case.

The PCA biplot is shown below:

```{python ch2-trick-question}
#| echo: false
#| warning: false

import numpy as np
import matplotlib.pyplot as plt

# -----------------------------------------------------------------------------
# 1) Loadings matrix (genes Ã— PCs) exactly as given:
loadings = np.array([
    [-0.5358995,   0.4181809,  -0.3412327,  0.6492278],   # Gene1
    [-0.5831836,   0.1879856,  -0.2681484, -0.7430748],   # Gene2
    [-0.2781909,  -0.8728062,  -0.3780158,  0.1338773],   # Gene3
    [-0.5434321,  -0.1673186,   0.8177779,  0.08902432],  # Gene4
])
genes = ['Gene1', 'Gene2', 'Gene3', 'Gene4']


# -----------------------------------------------------------------------------
# 2) Approximate PC2/PC3 scores from your biplot.
#    Fill in all 50 samples by eyeballing their (x, y) positions on the plot.
scores_dict = {
    # highlighted points:
    'Sample2':  (0.8,  2.1),
    'Sample24': (2.2, -0.5),
    'Sample33': (2.0, -0.4),
    # a few others for context:
    'Sample45': (1.2,  0.6),
    'Sample40': (1.8, -0.1),
    'Sample11': (-0.9, 0.0),
    'Sample39': (0.0, -1.2),
    'Sample28': (-0.7, 1.1),
    'Sample21': (-1.1, -0.8),
}

sample_labels = list(scores_dict.keys())
sample_scores = np.array([scores_dict[s] for s in sample_labels])


# -----------------------------------------------------------------------------
# 3) Plot PC2 vs PC3 biplot:
fig, ax = plt.subplots(figsize=(8,8))

# 3a) scatter the samples
ax.scatter(sample_scores[:,0], sample_scores[:,1],
           c='black', s=30, alpha=0.8)
for i, lbl in enumerate(sample_labels):
    ax.text(sample_scores[i,0], sample_scores[i,1], lbl,
            fontsize=8, ha='center', va='center')

# 3b) draw the gene loadings as red arrows
scale = 3.0
for i, gene in enumerate(genes):
    x_load = loadings[i,1] * scale  # PC2 loading
    y_load = loadings[i,2] * scale  # PC3 loading
    ax.arrow(0, 0, x_load, y_load,
             color='red', width=0.004, head_width=0.08,
             length_includes_head=True)
    ax.text(x_load*1.1, y_load*1.1, gene,
            color='red', fontsize=12, fontweight='bold')

# -----------------------------------------------------------------------------
# 4) Styling
ax.axhline(0, color='gray', linewidth=1)
ax.axvline(0, color='gray', linewidth=1)
ax.set_xlabel('PC2', fontsize=14)
ax.set_ylabel('PC3', fontsize=14)
#ax.set_title('PCA Biplot', fontsize=10)
ax.set_aspect('equal', 'box')
ax.grid(False)

plt.tight_layout()
plt.show()

```

The table of loadings is shown below:

```{python ch2-advanced-pca_loadings}
#| echo: false
#| warning: false

pcs   = ['PC1', 'PC2', 'PC3', 'PC4']

# 2) build a DataFrame
df = pd.DataFrame(loadings, index=genes, columns=pcs)

# 3) print it
print(df.to_string(float_format="{:.6f}".format))
```


:::::
<!-- end callout -->



::: {.callout-tip}
## Summary

- Need to normalize data before doing dimensionality reduction
- PCA reduces dimensionality for visualization.
- Clustering algorithms finds clusters in unlabeled data.
:::


## Resources

[1] [Article on normalization on Wikipedia](https://en.wikipedia.org/wiki/Standard_score)

[2] Deconvolution of monocyte responses in inflammatory bowel disease reveals an IL-1 cytokine network that regulates IL-23 in genetic and acquired IL-10 resistance Gut, 2020 [link](https://gut.bmj.com/content/70/6/1023)

[3] [ISLP book](https://www.statlearning.com/)

[4] [Video lectures by the authors of the book Introduction to Statistical Learning in Python](https://www.youtube.com/playlist?list=PLoROMvodv4rNHU1-iPeDRH-J0cL-CrIda)

[6] [Visual explanations of machine learning algorithms](https://mlu-explain.github.io)

---
