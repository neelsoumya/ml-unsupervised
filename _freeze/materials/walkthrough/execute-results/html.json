{
  "hash": "65189588ea907007b0c35307afa16f1d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Introduction to Unsupervised Learning\"\nformat: html\n---\n\n<!--\n## Markdown\n\nMarkdown is an easy to read and write text format:\n\n- It's _plain text_ so works well with version control\n- It can be **rendered** into HTML, PDF, and more\n- Learn more at: <https://quarto.org/docs/authoring/>\n-->\n\n## Learning Objectives\n\nBy the end of this module, learners will be able to:\n\n* Define unsupervised learning and explain how it differs from supervised learning in terms of inputs, outputs, and goals.\n\n* Identify common unsupervised techniques, including clustering (e.g., k‑means, hierarchical) and dimensionality reduction (e.g., PCA), and describe when each is appropriate.\n\n* Discuss real‑world applications of unsupervised learning, such as customer segmentation, anomaly detection, and image compression.\n\n* Explain the role of unsupervised learning in exploratory data analysis and as a preprocessing step for downstream tasks.\n\n* Interpret principal component analysis (PCA) intuitively, including the meaning of eigenvectors and eigenvalues, to understand how PCA finds the directions of greatest variance in data.\n\n* Apply dimensionality reduction to a simple multivariate dataset (e.g., crime rates and population by state) to visualize high‑dimensional data in two or three dimensions.\n\n* Differentiate unsupervised from supervised problems by examining datasets and deciding whether the task is to uncover patterns versus predict a known target variable.\n\n* Articulate the value of unsupervised learning in uncovering hidden structure in unlabelled data and its importance as data complexity and volume grow.\n\n\n## Introduction\n\nUnsupervised learning is a branch of machine learning that deals with finding hidden patterns or intrinsic structures in data without the use of labeled responses. Unlike supervised learning, where the model learns from labeled data to predict outcomes, unsupervised learning works with input data that does not have any corresponding output variables. The primary goal is to explore the underlying structure, groupings, or features in the data.\n\nOne of the most common applications of unsupervised learning is clustering, where the algorithm groups similar data points together based on their characteristics. This is particularly useful in scenarios such as customer segmentation, anomaly detection, and image compression. Another key technique is dimensionality reduction, which aims to reduce the number of variables under consideration, making it easier to visualize and interpret large datasets.\n\nUnsupervised learning is valuable because it can reveal insights that may not be immediately apparent, uncovering relationships and patterns that might otherwise go unnoticed. It is commonly used in exploratory data analysis and as a preprocessing step for other algorithms. As data continues to grow in complexity and volume, unsupervised learning plays a critical role in making sense of unstructured information.\n\n### Motivation\n\nHere is a picture I took of a pavement in Cambridge the day after Valentine's Day. Why did this picture capture my attention? The starkness of the grey pavement contrasted with the bright red rose. It may have triggered some unsupervised learning mechanism in my brain that allows me to pick anomalies!\n\n![Rose after Valentine's Day](images/rose_after_valentines_day.png)\n\nUnsupervised learning is all about discovering structure in data without any explicit “right answers” to guide you. Your rose‑on‑pavement photo is a perfect real‑world illustration of a few core ideas:\n\n* Anomaly (or Outlier) Detection\n- **What happened in your brain:**  \n  When you look at a uniform grey pavement, your visual system builds an internal “model” of what’s normal—flat, texture‑repeating, monochrome. The bright red rose doesn’t fit that model, so it “pops,” drawing your attention.\n\n- **In machine learning:**  \n  Algorithms like Isolation Forests, One‑Class SVMs, or autoencoder‑based detectors learn a representation of “normal” data (e.g. patches of pavement) and then flag anything that deviates significantly (e.g. the rose) as an anomaly.\n\n* Feature Extraction & Saliency\n- **Human vision analogy:**  \n  Early in the visual cortex, neurons respond to edges, color contrasts, textures. A red circle on grey evokes strong responses in “color” and “shape‑edge” channels.\n\n- **ML counterpart:**  \n  Techniques like PCA or deep autoencoders learn low‑dimensional “features” (color histograms, texture filters). Dimensions where the rose is extreme (high red‑channel value) are exactly the ones that give us the “anomaly” score.\n\n* Clustering & Pattern Discovery\nYou might not only notice the rose, but if there were lots of petals scattered around, your brain could start grouping (clustering) regions of similar color/shape.\n\nUnsupervised clustering algorithms (k‑means, DBSCAN) would partition image patches into clusters—“pavement patches,” “rose petals,” maybe even “shadows.” Anything that doesn’t belong to a big cluster may again be flagged as rare.\n\n* Dimensionality Reduction & Visualization\nIn a high‑dimensional feature space (e.g. each 10×10 pixel patch → a 300‑dim vector), you can’t “see” clusters easily. Algorithms like t‑SNE or UMAP compress that down to 2D so you can actually plot and see the rose‑patches separate from pavement.\n\nThis is why, for instance, visual analytics tools will show outliers as distant points on a scatterplot—just as you instantly spot the rose on the pavement.\n\n\n\n### Resources\n\n[PCA intuition](https://stats.stackexchange.com/questions/2691/making-sense-of-principal-component-analysis-eigenvectors-eigenvalues)\n\n\n### Key Concept \n\n![Information bottleneck](images/information_bottleneck.png)\n\nIn unsupervised learning, the __bottleneck concept__ refers to a deliberate architectural constraint in a model—typically an autoencoder—where information is compressed through a narrow intermediate representation, often called a latent code or embedding. The model is trained to reconstruct the input data after passing it through this low-dimensional bottleneck, forcing it to learn a compact and informative representation of the underlying structure of the data. Since there are no labels guiding the learning process, the model relies solely on reconstructing its input as accurately as possible, using only the limited information passed through this narrow channel. This compression encourages the model to capture essential features while discarding noise or redundancy.\n\nThe bottleneck acts as an inductive bias that promotes dimensionality reduction, feature learning, and denoising. By minimizing reconstruction error while constrained by a reduced latent space, the model implicitly discovers patterns, clusters, and hierarchies within the input data. In practical terms, this is a foundational principle behind many unsupervised representation learning methods, including classical autoencoders, variational autoencoders (VAEs), and self-supervised learning systems that rely on contrastive or generative objectives. The learned low-dimensional codes can then be used for downstream tasks such as clustering, visualization (e.g., with t-SNE or PCA), or as inputs to supervised models in a semi-supervised setting.\n\nmagine you have a huge library of biological images—say, pictures of different cell types under a microscope—and you want to teach a computer to recognize patterns in those images without telling it what any of the cells are. A “bottleneck” in this context is like asking the computer to summarize each image using only a few key words instead of the entire picture. By forcing it to compress all the rich detail down to a small summary, the computer has to figure out which features—like cell shape, size, or texture—are truly important. This is similar to how a biologist might sketch a simplified diagram of a cell, highlighting its nucleus and membrane but leaving out every ribosome and microtubule.\n\nBecause the computer must recreate the original image from that stripped‑down summary, it learns to ignore random noise or unimportant quirks (like slight variations in lighting) and focus on the core characteristics shared by similar cell types. In other words, the bottleneck helps the machine discover the hidden “essence” of the data. Once you have those concise summaries, you can use them to cluster cells into groups, visualize how different cell types relate, or even feed them into a second analysis—just as you might reduce a complex DNA dataset to a handful of genetic markers before drawing a phylogenetic tree. This approach lets you explore and interpret large biological datasets more effectively, all without ever providing explicit labels.\n\n### Example\n\nGiven the data below, how should we reduce the number of features and/or visualize it? This is an **unsupervised** machine learning problem.\n\n**NOTE (IMPORTANT CONCEPT)**: The columns of this data are the *features*.\n\n| State       | Murder (per 100k) | Robbery (per 100k) | Population     |\n|-------------|-------------------|--------------------|----------------|\n| California  | 9.1               | 45.3               | 39,512,223     |\n| Texas       | 7.8               | 38.6               | 28,995,881     |\n| Florida     | 5.9               | 31.7               | 21,477,737     |\n| New York    | 3.4               | 26.4               | 19,453,561     |\n| Illinois    | 6.4               | 35.1               | 12,671,821     |\n| Pennsylvania| 4.8               | 22.9               | 12,801,989     |\n\n\nImportantly, we are not trying to predict anything. For example, say in the data below we can try to predict the number of people who moved to that state last year. This is a **supervised** machine learning problem.\n\n| State        | Murder (per 100k) | Robbery (per 100k) | Population   | People Who Moved (per 100k) |\n|--------------|-------------------|--------------------|--------------|-----------------------------|\n| California   | 9.1               | 45.3               | 39,512,223   | 5,400                       |\n| Texas        | 7.8               | 38.6               | 28,995,881   | 4,100                       |\n| Florida      | 5.9               | 31.7               | 21,477,737   | 6,200                       |\n| New York     | 3.4               | 26.4               | 19,453,561   | 3,800                       |\n| Illinois     | 6.4               | 35.1               | 12,671,821   | 2,900                       |\n| Pennsylvania | 4.8               | 22.9               | 12,801,989   | 2,500                       |\n\n\n## What PCA does to the data\n\n<!--\n[PCA in 3D](https://github.com/neelsoumya/python_machine_learning/blob/main/pca_intro_3D_view.ipynb)\n-->\n\n\n\n### Projection of 3D Data\n\nWe generate three clusters of synthetic 3‑dimensional points, compute the first two principal components using scikit‑learn’s PCA, and then create a two‑panel figure:\n\n1. **Left panel**: A 3D scatter of the original points, the best‐fit plane defined by the first two principal components, and projection lines from each point down onto that plane.  \n2. **Right panel**: A 2D scatter of the projected coordinates (the principal component scores) along the first two components, colored by cluster.\n\nUse this visualization to understand how PCA finds the plane that maximizes variance and how the data look when reduced to two dimensions.\n\n\n\n::: {#aa171bb4 .cell execution_count=2}\n\n::: {.cell-output .cell-output-display}\n![](walkthrough_files/figure-html/cell-3-output-1.png){width=758 height=950}\n:::\n:::\n\n\n## PCA is lossy \n\nPCA does lose some information. But it can capture some/most of the salient aspects of your data. \n\n<!--\nThis is shown using the notebook below:\n\n[PCA lossy notebook](https://github.com/neelsoumya/python_machine_learning/blob/main/PCA_image_lossy_concept.ipynb)\n-->\n\n**NOTE (IMPORTANT CONCEPT)** \n\nDimensionality reduction techniques (such as PCA) always lose some information. In other words, it is *lossy*.\n\n### Lesson on lossy compression (PCA applied to image)\n\n### Learning Objectives\n\n* Understand how Principal Component Analysis (PCA) can be applied to images.\n* Observe how PCA captures the most significant patterns in image data.\n* Visualize how the number of principal components affects image reconstruction.\n* Appreciate the trade-off between compression and information loss.\n\n### Key Concepts\n\n* **PCA** is a dimensionality reduction technique that identifies directions (principal components) along which the variance in the data is maximized.\n* Images can be viewed as high-dimensional data (each pixel as a feature), and PCA helps reduce that dimensionality while preserving key patterns.\n\n### Procedure Overview\n\n1. **Load and display an image** from a URL.\n2. **Apply PCA to each RGB channel** of the image separately.\n3. **Reconstruct the image** using an increasing number of principal components.\n4. **Visualize the reconstructions** to show how few components capture most of the image's structure.\n\n::: {#38cfed8c .cell execution_count=3}\n\n::: {.cell-output .cell-output-display}\n![](walkthrough_files/figure-html/cell-4-output-1.png){width=296 height=409}\n:::\n\n::: {.cell-output .cell-output-display}\n![](walkthrough_files/figure-html/cell-4-output-2.png){width=1430 height=447}\n:::\n:::\n\n\n### Takeaway Message\n\nPCA can significantly reduce image data dimensionality while preserving salient features, making it a powerful tool for image compression and understanding. However, perfect reconstruction is only possible with all components, revealing the balance between efficiency and fidelity.\n\n\n\n## Activity: Playable version of PCA in browser\n\n[PCA in your browser](https://projector.tensorflow.org/)\n\n\n## Lesson Summary: Introduction to Unsupervised Learning\n\n* Basics of unsupervised learning\n\n* Useful for visualization, outlier detection and making sense of your data if there are many features\n\n- **What it is:** Discover hidden patterns or groupings in unlabeled data, without predicting a specific target.  \n- **Key techniques:**  \n  - **Clustering** (e.g. k‑means, hierarchical) for grouping similar observations  \n  - **Dimensionality reduction** (e.g. PCA) for compressing and visualizing high‑dimensional data  \n- **Why it matters:**  \n  - Reveals structure in customer segmentation, anomaly detection, image compression, etc.  \n  - Serves as exploratory analysis and preprocessing for downstream tasks  \n- **Information bottleneck:** Forcing models (like autoencoders) to squeeze data through a narrow “latent code” uncovers the most essential features and removes noise  \n- **Hands‑on example:** Apply PCA to crime‑and‑population data by state to project three features into two dimensions for visualization  \n- **Unsupervised vs. supervised:**  \n  - **Unsupervised:** No labels, focus on pattern discovery  \n  - **Supervised:** With labels, focus on predicting a known outcome \n\n\n\n\n## Acknowledgements\n\nWe thank Martin van Rongen, Vicki Hodgson, Hugo Tavares, Paul Fannon, Matt Castle and the Bioinformatics Facility Training Team for their support and guidance.\n\n\n## Resources\n\n- [Introduction to Statistical Learning in Python book](https://www.statlearning.com/)\n\n- [Video lectures by the authors of the book Introduction to Statistical Learning in Python](https://www.youtube.com/playlist?list=PLoROMvodv4rNHU1-iPeDRH-J0cL-CrIda)\n\n- https://github.com/neelsoumya/public_teaching_unsupervised_learning\n\n- [Interactive explanations of machine learning models](https://mlu-explain.github.io)\n\n- [Mathematics behind unsupervised machine learning](https://mml-book.github.io/book/mml-book.pdf)\n\n\n## Code Cell\n\nHere is a Python code cell:\n\n::: {#18a31ddf .cell execution_count=4}\n``` {.python .cell-code}\nimport os\nos.cpu_count()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n8\n```\n:::\n:::\n\n\n::: {#a8c83a0d .cell execution_count=5}\n``` {.python .cell-code}\nprint(\"Hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\n```\n:::\n:::\n\n\n## Equation\n\nUse LaTeX to write equations:\n\n$$\n\\chi' = \\sum_{i=1}^n k_i s_i^2\n$$\n\n",
    "supporting": [
      "walkthrough_files"
    ],
    "filters": [],
    "includes": {}
  }
}